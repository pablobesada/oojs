{"version":3,"sources":["Embedded_RecordTest.es6"],"names":[],"mappings":"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","file":"Embedded_RecordTest.js","sourcesContent":["\"use strict\";\n//var app = require(\"./../../app\")\nvar chance = new require(\"chance\")();\nvar _ = require(\"underscore\")\nvar oo = require(\"openorange\")\nvar query = oo.query;\nvar cm = oo.classmanager\nvar should = require('should');\nvar async = require('async')\nvar moment = require('moment')\nlet utils = null;\n\ndescribe(\"Embedded_Record\", function () {\n    let cls = cm.getClass(\"TestRecord\");\n    let cls2 = cm.getClass(\"TestRecord2\");\n    let rec = null;\n    let original_rec = null;\n\n    beforeEach(async () => {\n        await oo.beginTransaction();\n    })\n    after(async () => {\n        await oo.commit();\n    })\n\n    /*\n    it(\"create new record and set some field values\", async () => {\n        rec = cls.new();\n        rec.String_Field = 'ABCD'\n        let now = moment([2014,4-1,3]);\n        rec.Date_Field = now\n        should(rec.String_Field).be.equal('ABCD');\n        should(rec.Date_Field.isSame(now)).ok()\n    });\n\n    it(\"Linkto fields must get its length from the linked record\", async () => {\n        rec = cls.new();\n        let linkto_class = rec.fields(\"LinkTo_Field\").getLinktoRecordClass()\n        should(rec.fields(\"LinkTo_Field\").getMaxLength()).be.equal(linkto_class.getDescription().fields[linkto_class.uniqueKey()[0]].length)\n        should(rec.fields(\"String_Field\").getMaxLength()).be.equal(cls.getDescription().fields.String_Field.length)\n    });\n\n    it(\"create new record and store it\", async () => {\n        rec = cls.new().fillWithRandomValues()\n        let res = await rec.store();\n        res.should.be.true();\n        original_rec = rec.clone();\n    })\n\n    it(\"control for non-persistent fields\", async () => {\n        rec = cls.new().fillWithRandomValues()\n        rec.NonPersistent_Field = \"esto no deberia persistir\"\n        let row = rec.NonPersistent_Rows.newRow();\n        cls.fillRecordWithRandomValues(row)\n        rec.NonPersistent_Rows.push(row)\n        let res = await rec.store();\n        res.should.be.true();\n        let loaded_rec = await cls.findOne({internalId: rec.internalId})\n        should(loaded_rec.NonPersistent_Field).be.null();\n        should(loaded_rec.Rows.length).be.greaterThan(0);\n        should(loaded_rec.NonPersistent_Rows.length).be.equal(0);\n    })\n\n    it(\"load\", async () => {\n        rec = cls.new()\n        rec.internalId = original_rec.internalId;\n        rec.Date_Field = original_rec.Date_Field;\n        console.log(original_rec.Date_Field)\n        var res = await rec.load();\n        res.should.be.true(\"no se grabo\");\n        original_rec.syncOldFields();\n        rec.isEqual(original_rec).should.be.true(\"registros diferentes\");\n    })\n\n    it(\"Concurrent store (storing with old syncVersion)\", async () => {\n        let r1 = await cls.newSavedRecord();\n        let r2 = await cls.findOne({internalId: r1.internalId})\n        should(r1.isEqual(r2)).be.true()\n        r1.String_Field = 'r1'\n        r1.Integer_Field++;\n        should(await r1.store()).ok()\n        r2.Integer_Field--;\n        r2.String_Field = 'r2'\n        should(await r2.store()).not.ok()\n    })\n\n    it(\"Detail integrity against master syncVersion\", async () => {\n        let r1 = await cls.newSavedRecord();\n        let r2 = await cls.findOne({internalId: r1.internalId})\n        should(r1.isEqual(r2)).be.true()\n        console.log(r1)\n        console.log(r1.Rows)\n        console.log(r1.Rows.length)\n        r1.Rows[0].Integer_Field++;\n        should(await r1.store()).ok()\n        r2.Rows[0].Integer_Field--;\n        should(await r2.store()).not.ok()\n\n    })\n\n    it(\"Save new OK\", async ()=> {\n        rec = cls.new().fillWithRandomValues()\n        should(await rec.save()).be.true(\"El save no grabo\")\n        should.exist(await cls.findOne({internalId: rec.internalId, Integer_Field: rec.Integer_Field}), \"El save devolvio true, pero el registro no esta en la DB\")\n    })\n\n    it(\"Save with Check fail\", async ()=> {\n\n        let internalId = rec.internalId;\n        rec = await cls.findOne({internalId: rec.internalId})\n        should.exist(rec);\n        rec.checkReturnValue = false;\n        rec.Integer_Field++;\n        let res = await rec.save()\n        res.should.be.false(\"El save grabo y no deberia haberse grabado\")\n        should.not.exist(await cls.findOne({internalId: rec.internalId, Integer_Field: rec.Integer_Field}), \"El save devolvio false, pero igual grabo el registro\")\n    })\n\n    it(\"Save with beforeInsert fail\", async ()=> {\n        let rec = cls.new().fillWithRandomValues()\n        rec.beforeInsertReturnValue = false;\n        for (let i=0;i<3;i++) {\n            let record = cls.new().fillWithRandomValues()\n            record.SubTestName = \"Save with beforeInsert fail\"\n            rec.beforeInsert_recordsToStore.push(record);\n        }\n        rec.SubTestName = 'PARENT'\n        let res = await rec.save()\n        should(res).be.false(\"No deberia haber grabado\")\n        should.not.exist(await cls.findOne({String_Field: rec.String_Field}), \"El save devolvio false, pero igual grabo el registro\")\n        for (let i in rec.beforeInsert_recordsToStore) {\n            let record = rec.beforeInsert_recordsToStore[i]\n            should.not.exist(await cls.findOne({internalId: record.internalId, String_Field: record.String_Field}), \"El save devolvio false, pero igual grabo registros dentro del beforeInsert\")\n        }\n    });\n\n    it(\"Save with beforeUpdate fail\", async ()=> {\n        let rec = cls.new()\n        utils.fillRecord(rec)\n        rec.beforeUpdateReturnValue = false;\n\n        let res = await rec.save()\n        should(res).be.true(\"Deberia haber grabado\");\n        rec.Integer_Field++;\n\n        res = await rec.save();\n\n        should(res).be.false(\"No Deberia haber grabado\");\n        should.not.exist(await cls.findOne({internalId: rec.internalId, Integer_Field: rec.Integer_Field}), \"El save devolvio false, pero igual grabo el registro\")\n    })\n\n    it (\"Check if it makes rollback when storing record with wrong fields\", async () => {\n        //cls.__description__.fields['DUMMY'] = {type: \"string\", length: 30}\n        //cls.__description__.fieldnames.push(\"DUMMY\")\n        let rec = cls.new().fillWithRandomValues();\n        rec.beforeInsertReturnValue = false;\n        rec.SubTestName = 'TEST'\n        for (let i=0;i<3;i++) {\n            let record = cls2.new().fillWithRandomValues()\n            record.SubTestName = rec.SubTestName\n            rec.beforeInsert_recordsToStore.push(record);\n        }\n        let res = await rec.save();\n    });\n\n    it (\"delete record\", async () => {\n        should(true).be.false()\n    })\n\n    it (\"delete record check details and sets are gone\", async () => {\n        should(true).be.false()\n    })\n*/\n\n    it (\"check sets behaviour\", async () => {\n        rec = cls.new().fillWithRandomValues()\n        let res = await rec.store();\n        res.should.be.true();\n        let setvalues = _(rec.Set_Field.split(\",\")).map(function (v) {return v.trim()})\n        let response = await (await oo.getDBConnection()).query(`SELECT Value FROM ${rec.fields('Set_Field').setrecordname} WHERE masterId=?`, [rec.internalId])\n        let rset = response[0]\n        should(rset.length).be.equal(setvalues.length)\n        for (let i=0;i<setvalues.length;i++) {\n            should(rset[i].Value).be.equal(setvalues[i])\n        }\n        rec.Set_Field = chance.sentence({words: 2}).replace(/ /g, \",\").replace(/\\./g, \"\")\n        res = await rec.store();\n        res.should.be.true();\n        setvalues = _(rec.Set_Field.split(\",\")).map(function (v) {return v.trim()})\n        response = await (await oo.getDBConnection()).query(`SELECT Value FROM ${rec.fields('Set_Field').setrecordname} WHERE masterId=?`, [rec.internalId])\n        rset = response[0]\n        should(rset.length).be.equal(setvalues.length)\n        for (let i=0;i<setvalues.length;i++) {\n            should(rset[i].Value).be.equal(setvalues[i])\n        }\n\n    })\n});\n\nmodule.exports = function config(utilsModule) {\n    utils = utilsModule\n};"]}