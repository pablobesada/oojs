{"version":3,"sources":["minimatch.js"],"names":[],"mappings":"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","file":"minimatch-compiled.js","sourcesContent":[";(function (require, exports, module, platform) {\n\nif (module) module.exports = minimatch\nelse exports.minimatch = minimatch\n\nif (!require) {\n  require = function (id) {\n    switch (id) {\n      case \"sigmund\": return function sigmund (obj) {\n        return JSON.stringify(obj)\n      }\n      case \"path\": return { basename: function (f) {\n        f = f.split(/[\\/\\\\]/)\n        var e = f.pop()\n        if (!e) e = f.pop()\n        return e\n      }}\n      case \"lru-cache\": return function LRUCache () {\n        // not quite an LRU, but still space-limited.\n        var cache = {}\n        var cnt = 0\n        this.set = function (k, v) {\n          cnt ++\n          if (cnt >= 100) cache = {}\n          cache[k] = v\n        }\n        this.get = function (k) { return cache[k] }\n      }\n    }\n  }\n}\n\nminimatch.Minimatch = Minimatch\n\nvar LRU = require(\"lru-cache\")\n  , cache = minimatch.cache = new LRU({max: 100})\n  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\n  , sigmund = require(\"sigmund\")\n\nvar path = require(\"path\")\n  // any single thing other than /\n  // don't need to escape / when using new RegExp()\n  , qmark = \"[^/]\"\n\n  // * => any number of characters\n  , star = qmark + \"*?\"\n\n  // ** when dots are allowed.  Anything goes, except .. and .\n  // not (^ or / followed by one or two dots followed by $ or /),\n  // followed by anything, any number of times.\n  , twoStarDot = \"(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?\"\n\n  // not a ^ or / followed by a dot,\n  // followed by anything, any number of times.\n  , twoStarNoDot = \"(?:(?!(?:\\\\\\/|^)\\\\.).)*?\"\n\n  // characters that need to be escaped in RegExp.\n  , reSpecials = charSet(\"().*{}+?[]^$\\\\!\")\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split(\"\").reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== \"string\") {\n    throw new TypeError(\"glob pattern string required\")\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === \"#\") {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === \"\") return p === \"\"\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options, cache)\n  }\n\n  if (typeof pattern !== \"string\") {\n    throw new TypeError(\"glob pattern string required\")\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows: need to use /, not \\\n  // On other platforms, \\ is a valid (albeit bad) filename char.\n  if (platform === \"win32\") {\n    pattern = pattern.split(\"\\\\\").join(\"/\")\n  }\n\n  // lru storage.\n  // these things aren't particularly big, but walking down the string\n  // and turning it into a regexp can get pretty costly.\n  var cacheKey = pattern + \"\\n\" + sigmund(options)\n  var cached = minimatch.cache.get(cacheKey)\n  if (cached) return cached\n  minimatch.cache.set(cacheKey, this)\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function() {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === \"#\") {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return -1 === s.indexOf(false)\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n    , negate = false\n    , options = this.options\n    , negateOffset = 0\n\n  if (options.nonegate) return\n\n  for ( var i = 0, l = pattern.length\n      ; i < l && pattern.charAt(i) === \"!\"\n      ; i ++) {\n    negate = !negate\n    negateOffset ++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return new Minimatch(pattern, options).braceExpand()\n}\n\nMinimatch.prototype.braceExpand = braceExpand\nfunction braceExpand (pattern, options) {\n  options = options || this.options\n  pattern = typeof pattern === \"undefined\"\n    ? this.pattern : pattern\n\n  if (typeof pattern === \"undefined\") {\n    throw new Error(\"undefined pattern\")\n  }\n\n  if (options.nobrace ||\n      !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  var escaping = false\n\n  // examples and comments refer to this crazy pattern:\n  // a{b,c{d,e},{f,g}h}x{y,z}\n  // expected:\n  // abxy\n  // abxz\n  // acdxy\n  // acdxz\n  // acexy\n  // acexz\n  // afhxy\n  // afhxz\n  // aghxy\n  // aghxz\n\n  // everything before the first \\{ is just a prefix.\n  // So, we pluck that off, and work with the rest,\n  // and then prepend it to everything we find.\n  if (pattern.charAt(0) !== \"{\") {\n    this.debug(pattern)\n    var prefix = null\n    for (var i = 0, l = pattern.length; i < l; i ++) {\n      var c = pattern.charAt(i)\n      this.debug(i, c)\n      if (c === \"\\\\\") {\n        escaping = !escaping\n      } else if (c === \"{\" && !escaping) {\n        prefix = pattern.substr(0, i)\n        break\n      }\n    }\n\n    // actually no sets, all { were escaped.\n    if (prefix === null) {\n      this.debug(\"no sets\")\n      return [pattern]\n    }\n\n   var tail = braceExpand.call(this, pattern.substr(i), options)\n    return tail.map(function (t) {\n      return prefix + t\n    })\n  }\n\n  // now we have something like:\n  // {b,c{d,e},{f,g}h}x{y,z}\n  // walk through the set, expanding each part, until\n  // the set ends.  then, we'll expand the suffix.\n  // If the set only has a single member, then'll put the {} back\n\n  // first, handle numeric sets, since they're easier\n  var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/)\n  if (numset) {\n    this.debug(\"numset\", numset[1], numset[2])\n    var suf = braceExpand.call(this, pattern.substr(numset[0].length), options)\n      , start = +numset[1]\n      , end = +numset[2]\n      , inc = start > end ? -1 : 1\n      , set = []\n    for (var i = start; i != (end + inc); i += inc) {\n      // append all the suffixes\n      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n        set.push(i + suf[ii])\n      }\n    }\n    return set\n  }\n\n  // ok, walk through the set\n  // We hope, somewhat optimistically, that there\n  // will be a } at the end.\n  // If the closing brace isn't found, then the pattern is\n  // interpreted as braceExpand(\"\\\\\" + pattern) so that\n  // the leading \\{ will be interpreted literally.\n  var i = 1 // skip the \\{\n    , depth = 1\n    , set = []\n    , member = \"\"\n    , sawEnd = false\n    , escaping = false\n\n  function addMember () {\n    set.push(member)\n    member = \"\"\n  }\n\n  this.debug(\"Entering for\")\n  FOR: for (i = 1, l = pattern.length; i < l; i ++) {\n    var c = pattern.charAt(i)\n    this.debug(\"\", i, c)\n\n    if (escaping) {\n      escaping = false\n      member += \"\\\\\" + c\n    } else {\n      switch (c) {\n        case \"\\\\\":\n          escaping = true\n          continue\n\n        case \"{\":\n          depth ++\n          member += \"{\"\n          continue\n\n        case \"}\":\n          depth --\n          // if this closes the actual set, then we're done\n          if (depth === 0) {\n            addMember()\n            // pluck off the close-brace\n            i ++\n            break FOR\n          } else {\n            member += c\n            continue\n          }\n\n        case \",\":\n          if (depth === 1) {\n            addMember()\n          } else {\n            member += c\n          }\n          continue\n\n        default:\n          member += c\n          continue\n      } // switch\n    } // else\n  } // for\n\n  // now we've either finished the set, and the suffix is\n  // pattern.substr(i), or we have *not* closed the set,\n  // and need to escape the leading brace\n  if (depth !== 0) {\n    this.debug(\"didn't close\", pattern)\n    return braceExpand.call(this, \"\\\\\" + pattern, options)\n  }\n\n  // x{y,z} -> [\"xy\", \"xz\"]\n  this.debug(\"set\", set)\n  this.debug(\"suffix\", pattern.substr(i))\n  var suf = braceExpand.call(this, pattern.substr(i), options)\n  // [\"b\", \"c{d,e}\",\"{f,g}h\"] ->\n  //   [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]]\n  var addBraces = set.length === 1\n  this.debug(\"set pre-expanded\", set)\n  set = set.map(function (p) {\n    return braceExpand.call(this, p, options)\n  }, this)\n  this.debug(\"set expanded\", set)\n\n\n  // [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]] ->\n  //   [\"b\", \"cd\", \"ce\", \"fh\", \"gh\"]\n  set = set.reduce(function (l, r) {\n    return l.concat(r)\n  })\n\n  if (addBraces) {\n    set = set.map(function (s) {\n      return \"{\" + s + \"}\"\n    })\n  }\n\n  // now attach the suffixes.\n  var ret = []\n  for (var i = 0, l = set.length; i < l; i ++) {\n    for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n      ret.push(set[i] + suf[ii])\n    }\n  }\n  return ret\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === \"**\") return GLOBSTAR\n  if (pattern === \"\") return \"\"\n\n  var re = \"\"\n    , hasMagic = !!options.nocase\n    , escaping = false\n    // ? => one single character\n    , patternListStack = []\n    , plType\n    , stateChar\n    , inClass = false\n    , reClassStart = -1\n    , classStart = -1\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n    , patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n      // not (start or / followed by . or .. followed by / or end)\n      : options.dot ? \"(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))\"\n      : \"(?!\\\\.)\"\n    , self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case \"*\":\n          re += star\n          hasMagic = true\n          break\n        case \"?\":\n          re += qmark\n          hasMagic = true\n          break\n        default:\n          re += \"\\\\\"+stateChar\n          break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for ( var i = 0, len = pattern.length, c\n      ; (i < len) && (c = pattern.charAt(i))\n      ; i ++ ) {\n\n    this.debug(\"%s\\t%s %s %j\", pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += \"\\\\\" + c\n      escaping = false\n      continue\n    }\n\n    SWITCH: switch (c) {\n      case \"/\":\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case \"\\\\\":\n        clearStateChar()\n        escaping = true\n        continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case \"?\":\n      case \"*\":\n      case \"+\":\n      case \"@\":\n      case \"!\":\n        this.debug(\"%s\\t%s %s %j <-- stateChar\", pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === \"!\" && i === classStart + 1) c = \"^\"\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n        continue\n\n      case \"(\":\n        if (inClass) {\n          re += \"(\"\n          continue\n        }\n\n        if (!stateChar) {\n          re += \"\\\\(\"\n          continue\n        }\n\n        plType = stateChar\n        patternListStack.push({ type: plType\n                              , start: i - 1\n                              , reStart: re.length })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === \"!\" ? \"(?:(?!\" : \"(?:\"\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n        continue\n\n      case \")\":\n        if (inClass || !patternListStack.length) {\n          re += \"\\\\)\"\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        re += \")\"\n        plType = patternListStack.pop().type\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        switch (plType) {\n          case \"!\":\n            re += \"[^/]*?)\"\n            break\n          case \"?\":\n          case \"+\":\n          case \"*\": re += plType\n          case \"@\": break // the default anyway\n        }\n        continue\n\n      case \"|\":\n        if (inClass || !patternListStack.length || escaping) {\n          re += \"\\\\|\"\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += \"|\"\n        continue\n\n      // these are mostly the same in regexp and glob\n      case \"[\":\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += \"\\\\\" + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n        continue\n\n      case \"]\":\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += \"\\\\\" + c\n          escaping = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n        continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n                   && !(c === \"^\" && inClass)) {\n          re += \"\\\\\"\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    var cs = pattern.substr(classStart + 1)\n      , sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  var pl\n  while (pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + 3)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = \"\\\\\"\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + \"|\"\n    })\n\n    this.debug(\"tail=%j\\n   %s\", tail, tail)\n    var t = pl.type === \"*\" ? star\n          : pl.type === \"?\" ? qmark\n          : \"\\\\\" + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart)\n       + t + \"\\\\(\"\n       + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += \"\\\\\\\\\"\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case \".\":\n    case \"[\":\n    case \"(\": addPatternStart = true\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== \"\" && hasMagic) re = \"(?=.)\" + re\n\n  if (addPatternStart) re = patternStart + re\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [ re, hasMagic ]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? \"i\" : \"\"\n    , regExp = new RegExp(\"^\" + re + \"$\", flags)\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) return this.regexp = false\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n      : options.dot ? twoStarDot\n      : twoStarNoDot\n    , flags = options.nocase ? \"i\" : \"\"\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n           : (typeof p === \"string\") ? regExpEscape(p)\n           : p._src\n    }).join(\"\\\\\\/\")\n  }).join(\"|\")\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = \"^(?:\" + re + \")$\"\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = \"^(?!\" + re + \").*$\"\n\n  try {\n    return this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    return this.regexp = false\n  }\n}\n\nminimatch.match = function (list, pattern, options) {\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug(\"match\", f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === \"\"\n\n  if (f === \"/\" && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  // On other platforms, \\ is a valid (albeit bad) filename char.\n  if (platform === \"win32\") {\n    f = f.split(\"\\\\\").join(\"/\")\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, \"split\", f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, \"set\", set)\n\n  var splitFile = path.basename(f.join(\"/\")).split(\"/\")\n\n  for (var i = 0, l = set.length; i < l; i ++) {\n    var pattern = set[i], file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = splitFile\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug(\"matchOne\",\n              { \"this\": this\n              , file: file\n              , pattern: pattern })\n\n  this.debug(\"matchOne\", file.length, pattern.length)\n\n  for ( var fi = 0\n          , pi = 0\n          , fl = file.length\n          , pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi ++, pi ++ ) {\n\n    this.debug(\"matchOne loop\")\n    var p = pattern[pi]\n      , f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n        , pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for ( ; fi < fl; fi ++) {\n          if (file[fi] === \".\" || file[fi] === \"..\" ||\n              (!options.dot && file[fi].charAt(0) === \".\")) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      WHILE: while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while',\n                    file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === \".\" || swallowee === \"..\" ||\n              (!options.dot && swallowee.charAt(0) === \".\")) {\n            this.debug(\"dot detected!\", file, fr, pattern, pr)\n            break WHILE\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr ++\n        }\n      }\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then \n      if (partial) {\n        // ran out of file\n        this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === \"string\") {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug(\"string match\", p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug(\"pattern match\", p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === \"\")\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error(\"wtf?\")\n}\n\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, \"$1\")\n}\n\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")\n}\n\n})( typeof require === \"function\" ? require : null,\n    this,\n    typeof module === \"object\" ? module : null,\n    typeof process === \"object\" ? process.platform : \"win32\"\n  )\n"]}