{"version":3,"sources":["promise.js"],"names":[],"mappings":"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","file":"promise-compiled.js","sourcesContent":["/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('../util');\nvar PromisedAssertion = require('../assertion').PromisedAssertion;\nvar Assertion = require('../assertion');\n\nmodule.exports = function(should) {\n  /**\n   * Assert given object is a Promise\n   *\n   * @name Promise\n   * @memberOf Assertion\n   * @category assertion promises\n   * @example\n   *\n   * promise.should.be.Promise()\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.a.Promise()\n   * (10).should.not.be.a.Promise()\n   */\n  Assertion.add('Promise', function() {\n    this.params = {operator: 'to be promise'};\n\n    var obj = this.obj;\n\n    should(obj).have.property('then')\n      .which.is.a.Function();\n  });\n\n  /**\n   * Assert given promise will be fulfilled. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilled\n   * @memberOf Assertion\n   * @returns {Promise}\n   * @category assertion promises\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.fulfilled();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.fulfilled();\n   * });\n   */\n  Assertion.prototype.fulfilled = function Assertion$fulfilled() {\n    this.params = {operator: 'to be fulfilled'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function next$onResolve(value) {\n      if (that.negate) {\n        that.fail();\n      }\n      return value;\n    }, function next$onReject(err) {\n      if (!that.negate) {\n        that.params.operator += ', but it was rejected with ' + should.format(err);\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be rejected. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejected\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.not.be.rejected();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => reject(new Error('boom')))\n   *      .should.be.rejected();\n   * });\n   */\n  Assertion.prototype.rejected = function() {\n    this.params = {operator: 'to be rejected'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (!that.negate) {\n        that.params.operator += ', but it was fulfilled';\n        if (arguments.length != 0) {\n          that.params.operator += ' with ' + should.format(value);\n        }\n        that.fail();\n      }\n      return value;\n    }, function next$onError(err) {\n      if (that.negate) {\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be fulfilled with some expected value (value compared using .eql).\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilledWith\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.fulfilledWith(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => resolve(10))\n   *       .should.be.fulfilledWith(10);\n   * });\n   */\n  Assertion.prototype.fulfilledWith = function(expectedValue) {\n    this.params = {operator: 'to be fulfilled with ' + should.format(expectedValue)};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (that.negate) {\n        that.fail();\n      }\n      should(value).eql(expectedValue);\n      return value;\n    }, function next$onError(err) {\n      if (!that.negate) {\n        that.params.operator += ', but it was rejected with ' + should.format(err);\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be rejected with some sort of error. Arguments is the same for Assertion#throw.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejectedWith\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * function failedPromise() {\n   *   return new Promise(function(resolve, reject) {\n   *     reject(new Error('boom'))\n   *   })\n   * }\n   * failedPromise().should.be.rejectedWith(Error);\n   * failedPromise().should.be.rejectedWith('boom');\n   * failedPromise().should.be.rejectedWith(/boom/);\n   * failedPromise().should.be.rejectedWith(Error, { message: 'boom' });\n   * failedPromise().should.be.rejectedWith({ message: 'boom' });\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return failedPromise().should.be.rejectedWith({ message: 'boom' });\n   * });\n   */\n  Assertion.prototype.rejectedWith = function(message, properties) {\n    this.params = {operator: 'to be rejected'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (!that.negate) {\n        that.fail();\n      }\n      return value;\n    }, function next$onError(err) {\n      if (that.negate) {\n        that.fail();\n      }\n\n      var errorMatched = true;\n      var errorInfo = '';\n\n      if ('string' === typeof message) {\n        errorMatched = message === err.message;\n      } else if (message instanceof RegExp) {\n        errorMatched = message.test(err.message);\n      } else if ('function' === typeof message) {\n        errorMatched = err instanceof message;\n      } else if (message !== null && typeof message === 'object') {\n        try {\n          should(err).match(message);\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            errorInfo = ': ' + e.message;\n            errorMatched = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      if (!errorMatched) {\n        if ( typeof message === 'string' || message instanceof RegExp) {\n          errorInfo = ' with a message matching ' + should.format(message) + \", but got '\" + err.message + \"'\";\n        } else if ('function' === typeof message) {\n          errorInfo = ' of type ' + util.functionName(message) + ', but got ' + util.functionName(err.constructor);\n        }\n      } else if ('function' === typeof message && properties) {\n        try {\n          should(err).match(properties);\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            errorInfo = ': ' + e.message;\n            errorMatched = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      that.params.operator += errorInfo;\n\n      that.assert(errorMatched);\n\n      return err;\n    });\n  };\n\n  /**\n   * Assert given object is promise and wrap it in PromisedAssertion, which has all properties of Assertion.\n   * That means you can chain as with usual Assertion.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name finally\n   * @memberOf Assertion\n   * @alias Assertion#eventually\n   * @category assertion promises\n   * @returns {PromisedAssertion} Like Assertion, but .then this.obj in Assertion\n   * @example\n   *\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.eventually.equal(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.finally.equal(10);\n   * });\n   */\n  Object.defineProperty(Assertion.prototype, 'finally', {\n    get: function() {\n      should(this.obj).be.a.Promise();\n\n      var that = this;\n\n      return new PromisedAssertion(this.obj.then(function(obj) {\n        var a = should(obj);\n\n        a.negate = that.negate;\n        a.anyOne = that.anyOne;\n\n        return a;\n      }));\n    }\n  });\n\n  Assertion.alias('finally', 'eventually');\n};\n"]}