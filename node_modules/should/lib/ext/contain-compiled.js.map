{"version":3,"sources":["contain.js"],"names":[],"mappings":"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","file":"contain-compiled.js","sourcesContent":["/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('../util');\nvar eql = require('should-equal');\n\nmodule.exports = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Assert that given object contain something that equal to `other`. It uses `should-equal` for equality checks.\n   * If given object is array it search that one of elements was equal to `other`.\n   * If given object is string it checks if `other` is a substring - expected that `other` is a string.\n   * If given object is Object it checks that `other` is a subobject - expected that `other` is a object.\n   *\n   * @name containEql\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [1, 2, 3].should.containEql(1);\n   * [{ a: 1 }, 'a', 10].should.containEql({ a: 1 });\n   *\n   * 'abc'.should.containEql('b');\n   * 'ab1c'.should.containEql(1);\n   *\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ a: 10 });\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ c: { d: 10 }});\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ b: 10 });\n   * // throws AssertionError: expected { a: 10, c: { d: 10 } } to contain { b: 10 }\n   * //            expected { a: 10, c: { d: 10 } } to have property b\n   */\n  Assertion.add('containEql', function(other) {\n    this.params = {operator: 'to contain ' + i(other)};\n\n    this.is.not.null().and.not.undefined();\n\n    var obj = this.obj;\n\n    if (typeof obj == 'string') {\n      this.assert(obj.indexOf(String(other)) >= 0);\n    } else if (util.isIndexable(obj)) {\n      this.assert(util.some(obj, function(v) {\n        return eql(v, other).result;\n      }));\n    } else {\n      this.have.properties(other);\n    }\n  });\n\n  /**\n   * Assert that given object is contain equally structured object on the same depth level.\n   * If given object is an array and `other` is an array it checks that the eql elements is going in the same sequence in given array (recursive)\n   * If given object is an object it checks that the same keys contain deep equal values (recursive)\n   * On other cases it try to check with `.eql`\n   *\n   * @name containDeepOrdered\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeepOrdered([1, 2]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeepOrdered([ 1, [ 2, 3 ]]);\n   *\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({a: 10});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {c: 10}});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {d: [1, 3]}});\n   */\n  Assertion.add('containDeepOrdered', function(other) {\n    this.params = {operator: 'to contain ' + i(other)};\n\n    var obj = this.obj;\n    if (typeof obj == 'string') {// expect other to be string\n      this.is.equal(String(other));\n    } else if (util.isIndexable(obj) && util.isIndexable(other)) {\n      for (var objIdx = 0, otherIdx = 0, objLength = util.length(obj), otherLength = util.length(other); objIdx < objLength && otherIdx < otherLength; objIdx++) {\n        try {\n          should(obj[objIdx]).containDeepOrdered(other[otherIdx]);\n          otherIdx++;\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            continue;\n          }\n          throw e;\n        }\n      }\n\n      this.assert(otherIdx === otherLength);\n    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {// object contains object case\n      util.forEach(other, function(value, key) {\n        should(obj[key]).containDeepOrdered(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (util.isEmptyObject(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n\n  /**\n   * The same like `Assertion#containDeepOrdered` but all checks on arrays without order.\n   *\n   * @name containDeep\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeep([2, 1]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeep([ 1, [ 3, 1 ]]);\n   */\n  Assertion.add('containDeep', function(other) {\n    this.params = {operator: 'to contain ' + i(other)};\n\n    var obj = this.obj;\n    if (typeof obj == 'string') {// expect other to be string\n      this.is.equal(String(other));\n    } else if (util.isIndexable(obj) && util.isIndexable(other)) {\n      var usedKeys = {};\n      util.forEach(other, function(otherItem) {\n        this.assert(util.some(obj, function(item, index) {\n          if (index in usedKeys) return false;\n\n          try {\n            should(item).containDeep(otherItem);\n            usedKeys[index] = true;\n            return true;\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              return false;\n            }\n            throw e;\n          }\n        }));\n      }, this);\n    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {// object contains object case\n      util.forEach(other, function(value, key) {\n        should(obj[key]).containDeep(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (util.isEmptyObject(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n\n};\n"]}