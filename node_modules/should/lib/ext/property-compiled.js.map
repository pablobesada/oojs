{"version":3,"sources":["property.js"],"names":[],"mappings":"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","file":"property-compiled.js","sourcesContent":["/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('../util');\nvar eql = require('should-equal');\n\nvar aSlice = Array.prototype.slice;\n\nmodule.exports = function(should, Assertion) {\n  var i = should.format;\n  /**\n   * Asserts given object has some descriptor. **On success it change given object to be value of property**.\n   *\n   * @name propertyWithDescriptor\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {Object} desc Descriptor like used in Object.defineProperty (not required to add all properties)\n   * @example\n   *\n   * ({ a: 10 }).should.have.propertyWithDescriptor('a', { enumerable: true });\n   */\n  Assertion.add('propertyWithDescriptor', function(name, desc) {\n    this.params = {actual: this.obj, operator: 'to have own property with descriptor ' + i(desc)};\n    var obj = this.obj;\n    this.have.ownProperty(name);\n    should(Object.getOwnPropertyDescriptor(Object(obj), name)).have.properties(desc);\n  });\n\n  function processPropsArgs() {\n    var args = {};\n    if (arguments.length > 1) {\n      args.names = aSlice.call(arguments);\n    } else {\n      var arg = arguments[0];\n      if (typeof arg === 'string') {\n        args.names = [arg];\n      } else if (util.isIndexable(arg)) {\n        args.names = arg;\n      } else {\n        args.names = Object.keys(arg);\n        args.values = arg;\n      }\n    }\n    return args;\n  }\n\n\n  /**\n   * Asserts given object has enumerable property with optionally value. **On success it change given object to be value of property**.\n   *\n   * @name enumerable\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {*} [val] Optional property value to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.enumerable('a');\n   */\n  Assertion.add('enumerable', function(name, val) {\n    name = util.convertPropertyName(name);\n\n    this.params = {\n      operator: \"to have enumerable property \" + util.formatProp(name) + (arguments.length > 1 ? \" equal to \" + i(val): \"\")\n    };\n\n    var desc = { enumerable: true };\n    if (arguments.length > 1) desc.value = val;\n    this.have.propertyWithDescriptor(name, desc);\n  });\n\n  /**\n   * Asserts given object has enumerable properties\n   *\n   * @name enumerables\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string|Object} names Names of property\n   * @example\n   *\n   * ({ a: 10, b: 10 }).should.have.enumerables('a');\n   */\n  Assertion.add('enumerables', function(/*names*/) {\n    var args = processPropsArgs.apply(null, arguments);\n\n    this.params = {\n      operator: \"to have enumerables \" + args.names.map(util.formatProp)\n    };\n\n    var obj = this.obj;\n    args.names.forEach(function(name) {\n      should(obj).have.enumerable(name);\n    });\n  });\n\n  /**\n   * Asserts given object has property with optionally value. **On success it change given object to be value of property**.\n   *\n   * @name property\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {*} [val] Optional property value to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.property('a');\n   */\n  Assertion.add('property', function(name, val) {\n    name = util.convertPropertyName(name);\n    if (arguments.length > 1) {\n      var p = {};\n      p[name] = val;\n      this.have.properties(p);\n    } else {\n      this.have.properties(name);\n    }\n    this.obj = this.obj[name];\n  });\n\n  /**\n   * Asserts given object has properties. On this method affect .any modifier, which allow to check not all properties.\n   *\n   * @name properties\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string|Object} names Names of property\n   * @example\n   *\n   * ({ a: 10 }).should.have.properties('a');\n   * ({ a: 10, b: 20 }).should.have.properties([ 'a' ]);\n   * ({ a: 10, b: 20 }).should.have.properties({ b: 20 });\n   */\n  Assertion.add('properties', function(names) {\n    var values = {};\n    if (arguments.length > 1) {\n      names = aSlice.call(arguments);\n    } else if (!Array.isArray(names)) {\n      if (typeof names == 'string' || typeof names == 'symbol') {\n        names = [names];\n      } else {\n        values = names;\n        names = Object.keys(names);\n      }\n    }\n\n    var obj = Object(this.obj), missingProperties = [];\n\n    //just enumerate properties and check if they all present\n    names.forEach(function(name) {\n      if (!(name in obj)) missingProperties.push(util.formatProp(name));\n    });\n\n    var props = missingProperties;\n    if (props.length === 0) {\n      props = names.map(util.formatProp);\n    } else if (this.anyOne) {\n      props = names.filter(function(name) {\n        return missingProperties.indexOf(util.formatProp(name)) < 0;\n      }).map(util.formatProp);\n    }\n\n    var operator = (props.length === 1 ?\n        'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');\n\n    this.params = {obj: this.obj, operator: operator};\n\n    //check that all properties presented\n    //or if we request one of them that at least one them presented\n    this.assert(missingProperties.length === 0 || (this.anyOne && missingProperties.length != names.length));\n\n    // check if values in object matched expected\n    var valueCheckNames = Object.keys(values);\n    if (valueCheckNames.length) {\n      var wrongValues = [];\n      props = [];\n\n      // now check values, as there we have all properties\n      valueCheckNames.forEach(function(name) {\n        var value = values[name];\n        if (!eql(obj[name], value).result) {\n          wrongValues.push(util.formatProp(name) + ' of ' + i(value) + ' (got ' + i(obj[name]) + ')');\n        } else {\n          props.push(util.formatProp(name) + ' of ' + i(value));\n        }\n      });\n\n      if ((wrongValues.length !== 0 && !this.anyOne) || (this.anyOne && props.length === 0)) {\n        props = wrongValues;\n      }\n\n      operator = (props.length === 1 ?\n        'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');\n\n      this.params = {obj: this.obj, operator: operator};\n\n      //if there is no not matched values\n      //or there is at least one matched\n      this.assert(wrongValues.length === 0 || (this.anyOne && wrongValues.length != valueCheckNames.length));\n    }\n  });\n\n  /**\n   * Asserts given object has property `length` with given value `n`\n   *\n   * @name length\n   * @alias Assertion#lengthOf\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {number} n Expected length\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * [1, 2].should.have.length(2);\n   */\n  Assertion.add('length', function(n, description) {\n    this.have.property('length', n, description);\n  });\n\n  Assertion.alias('length', 'lengthOf');\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  /**\n   * Asserts given object has own property. **On success it change given object to be value of property**.\n   *\n   * @name ownProperty\n   * @alias Assertion#hasOwnProperty\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * ({ a: 10 }).should.have.ownProperty('a');\n   */\n  Assertion.add('ownProperty', function(name, description) {\n    name = util.convertPropertyName(name);\n    this.params = {\n      actual: this.obj,\n      operator: 'to have own property ' + util.formatProp(name),\n      message: description\n    };\n\n    this.assert(hasOwnProperty.call(this.obj, name));\n\n    this.obj = this.obj[name];\n  });\n\n  Assertion.alias('ownProperty', 'hasOwnProperty');\n\n  /**\n   * Asserts given object is empty. For strings, arrays and arguments it checks .length property, for objects it checks keys.\n   *\n   * @name empty\n   * @memberOf Assertion\n   * @category assertion property\n   * @example\n   *\n   * ''.should.be.empty();\n   * [].should.be.empty();\n   * ({}).should.be.empty();\n   */\n  Assertion.add('empty', function() {\n    this.params = {operator: 'to be empty'};\n\n    if (util.length(this.obj) !== void 0) {\n      should(this.obj).have.property('length', 0);\n    } else {\n      var obj = Object(this.obj); // wrap to reference for booleans and numbers\n      for (var prop in obj) {\n        should(this.obj).not.have.ownProperty(prop);\n      }\n    }\n  }, true);\n\n  /**\n   * Asserts given object has exact keys. Compared to `properties`, `keys` does not accept Object as a argument.\n   *\n   * @name keys\n   * @alias Assertion#key\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string} [keys] Keys to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.keys('a');\n   * ({ a: 10, b: 20 }).should.have.keys('a', 'b');\n   * ({ a: 10, b: 20 }).should.have.keys([ 'a', 'b' ]);\n   * ({}).should.have.keys();\n   */\n  Assertion.add('keys', function(keys) {\n    if (arguments.length > 1) keys = aSlice.call(arguments);\n    else if (arguments.length === 1 && typeof keys === 'string') keys = [keys];\n    else if (arguments.length === 0) keys = [];\n\n    keys = keys.map(String);\n\n    var obj = Object(this.obj);\n\n    // first check if some keys are missing\n    var missingKeys = [];\n    keys.forEach(function(key) {\n      if (!hasOwnProperty.call(this.obj, key))\n        missingKeys.push(util.formatProp(key));\n    }, this);\n\n    // second check for extra keys\n    var extraKeys = [];\n    Object.keys(obj).forEach(function(key) {\n      if (keys.indexOf(key) < 0) {\n        extraKeys.push(util.formatProp(key));\n      }\n    });\n\n    var verb = keys.length === 0 ? 'to be empty' :\n    'to have ' + (keys.length === 1 ? 'key ' : 'keys ');\n\n    this.params = {operator: verb + keys.map(util.formatProp).join(', ')};\n\n    if (missingKeys.length > 0)\n      this.params.operator += '\\n\\tmissing keys: ' + missingKeys.join(', ');\n\n    if (extraKeys.length > 0)\n      this.params.operator += '\\n\\textra keys: ' + extraKeys.join(', ');\n\n    this.assert(missingKeys.length === 0 && extraKeys.length === 0);\n  });\n\n  Assertion.alias(\"keys\", \"key\");\n\n  /**\n   * Asserts given object has nested property in depth by path. **On success it change given object to be value of final property**.\n   *\n   * @name propertyByPath\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string} properties Properties path to search\n   * @example\n   *\n   * ({ a: {b: 10}}).should.have.propertyByPath('a', 'b').eql(10);\n   */\n  Assertion.add('propertyByPath', function(properties) {\n    if (arguments.length > 1) properties = aSlice.call(arguments);\n    else if (arguments.length === 1 && typeof properties == 'string') properties = [properties];\n    else if (arguments.length === 0) properties = [];\n\n    var allProps = properties.map(util.formatProp);\n\n    properties = properties.map(String);\n\n    var obj = should(Object(this.obj));\n\n    var foundProperties = [];\n\n    var currentProperty;\n    while (properties.length) {\n      currentProperty = properties.shift();\n      this.params = {operator: 'to have property by path ' + allProps.join(', ') + ' - failed on ' + util.formatProp(currentProperty)};\n      obj = obj.have.property(currentProperty);\n      foundProperties.push(currentProperty);\n    }\n\n    this.params = {obj: this.obj, operator: 'to have property by path ' + allProps.join(', ')};\n\n    this.obj = obj.obj;\n  });\n};\n"]}