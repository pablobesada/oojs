{"version":3,"sources":["match.js"],"names":[],"mappings":"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","file":"match-compiled.js","sourcesContent":["/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('../util');\nvar eql = require('should-equal');\n\nmodule.exports = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Asserts if given object match `other` object, using some assumptions:\n   * First object matched if they are equal,\n   * If `other` is a regexp and given object is a string check on matching with regexp\n   * If `other` is a regexp and given object is an array check if all elements matched regexp\n   * If `other` is a regexp and given object is an object check values on matching regexp\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n   * If `other` is an object check if the same keys matched with above rules\n   * All other cases failed.\n   *\n   * Usually it is right idea to add pre type assertions, like `.String()` or `.Object()` to be sure assertions will do what you are expecting.\n   * Object iteration happen by keys (properties with enumerable: true), thus some objects can cause small pain. Typical example is js\n   * Error - it by default has 2 properties `name` and `message`, but they both non-enumerable. In this case make sure you specify checking props (see examples).\n   *\n   * @name match\n   * @memberOf Assertion\n   * @category assertion matching\n   * @param {*} other Object to match\n   * @param {string} [description] Optional message\n   * @example\n   * 'foobar'.should.match(/^foo/);\n   * 'foobar'.should.not.match(/^bar/);\n   *\n   * ({ a: 'foo', c: 'barfoo' }).should.match(/foo$/);\n   *\n   * ['a', 'b', 'c'].should.match(/[a-z]/);\n   *\n   * (5).should.not.match(function(n) {\n   *   return n < 0;\n   * });\n   * (5).should.not.match(function(it) {\n   *    it.should.be.an.Array();\n   * });\n   * ({ a: 10, b: 'abc', c: { d: 10 }, d: 0 }).should\n   * .match({ a: 10, b: /c$/, c: function(it) {\n   *    return it.should.have.property('d', 10);\n   * }});\n   *\n   * [10, 'abc', { d: 10 }, 0].should\n   * .match({ '0': 10, '1': /c$/, '2': function(it) {\n   *    return it.should.have.property('d', 10);\n   * }});\n   *\n   * var myString = 'abc';\n   *\n   * myString.should.be.a.String().and.match(/abc/);\n   *\n   * myString = {};\n   *\n   * myString.should.match(/abc/); //yes this will pass\n   * //better to do\n   * myString.should.be.an.Object().and.not.empty().and.match(/abc/);//fixed\n   *\n   * (new Error('boom')).should.match(/abc/);//passed because no keys\n   * (new Error('boom')).should.not.match({ message: /abc/ });//check specified property\n   */\n  Assertion.add('match', function(other, description) {\n    this.params = {operator: 'to match ' + i(other), message: description};\n\n    if (!eql(this.obj, other).result) {\n      if (other instanceof RegExp) { // something - regex\n\n        if (typeof this.obj == 'string') {\n\n          this.assert(other.exec(this.obj));\n        } else if (util.isIndexable(this.obj)) {\n          util.forEach(this.obj, function(item) {\n            this.assert(other.exec(item));// should we try to convert to String and exec?\n          }, this);\n        } else if (null != this.obj && typeof this.obj == 'object') {\n\n          var notMatchedProps = [], matchedProps = [];\n          util.forEach(this.obj, function(value, name) {\n            if (other.exec(value)) matchedProps.push(util.formatProp(name));\n            else notMatchedProps.push(util.formatProp(name) + ' (' + i(value) + ')');\n          }, this);\n\n          if (notMatchedProps.length)\n            this.params.operator += '\\n    not matched properties: ' + notMatchedProps.join(', ');\n          if (matchedProps.length)\n            this.params.operator += '\\n    matched properties: ' + matchedProps.join(', ');\n\n          this.assert(notMatchedProps.length === 0);\n        } // should we try to convert to String and exec?\n      } else if (typeof other == 'function') {\n        var res;\n\n        res = other(this.obj);\n\n        //if(res instanceof Assertion) {\n        //  this.params.operator += '\\n    ' + res.getMessage();\n        //}\n\n        //if we throw exception ok - it is used .should inside\n        if (typeof res == 'boolean') {\n          this.assert(res); // if it is just boolean function assert on it\n        }\n      } else if (other != null && this.obj != null && typeof other == 'object' && typeof this.obj == 'object') { // try to match properties (for Object and Array)\n        notMatchedProps = [];\n        matchedProps = [];\n\n        util.forEach(other, function(value, key) {\n          try {\n            should(this.obj).have.property(key).which.match(value);\n            matchedProps.push(util.formatProp(key));\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              notMatchedProps.push(util.formatProp(key) + ' (' + i(this.obj[key]) + ')');\n            } else {\n              throw e;\n            }\n          }\n        }, this);\n\n        if (notMatchedProps.length)\n          this.params.operator += '\\n    not matched properties: ' + notMatchedProps.join(', ');\n        if (matchedProps.length)\n          this.params.operator += '\\n    matched properties: ' + matchedProps.join(', ');\n\n        this.assert(notMatchedProps.length === 0);\n      } else {\n        this.assert(false);\n      }\n    }\n  });\n\n  /**\n   * Asserts if given object values or array elements all match `other` object, using some assumptions:\n   * First object matched if they are equal,\n   * If `other` is a regexp - matching with regexp\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n   * All other cases check if this `other` equal to each element\n   *\n   * @name matchEach\n   * @memberOf Assertion\n   * @category assertion matching\n   * @alias Assertion#matchEvery\n   * @param {*} other Object to match\n   * @param {string} [description] Optional message\n   * @example\n   * [ 'a', 'b', 'c'].should.matchEach(/\\w+/);\n   * [ 'a', 'a', 'a'].should.matchEach('a');\n   *\n   * [ 'a', 'a', 'a'].should.matchEach(function(value) { value.should.be.eql('a') });\n   *\n   * { a: 'a', b: 'a', c: 'a' }.should.matchEach(function(value) { value.should.be.eql('a') });\n   */\n  Assertion.add('matchEach', function(other, description) {\n    this.params = {operator: 'to match each ' + i(other), message: description};\n\n    util.forEach(this.obj, function(value) {\n      should(value).match(other);\n    }, this);\n  });\n\n  /**\n  * Asserts if any of given object values or array elements match `other` object, using some assumptions:\n  * First object matched if they are equal,\n  * If `other` is a regexp - matching with regexp\n  * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n  * All other cases check if this `other` equal to each element\n  *\n  * @name matchAny\n  * @memberOf Assertion\n  * @category assertion matching\n  * @param {*} other Object to match\n  * @alias Assertion#matchSome\n  * @param {string} [description] Optional message\n  * @example\n  * [ 'a', 'b', 'c'].should.matchAny(/\\w+/);\n  * [ 'a', 'b', 'c'].should.matchAny('a');\n  *\n  * [ 'a', 'b', 'c'].should.matchAny(function(value) { value.should.be.eql('a') });\n  *\n  * { a: 'a', b: 'b', c: 'c' }.should.matchAny(function(value) { value.should.be.eql('a') });\n  */\n  Assertion.add('matchAny', function(other, description) {\n    this.params = {operator: 'to match any ' + i(other), message: description};\n\n    this.assert(util.some(this.obj, function(value) {\n      try {\n        should(value).match(other);\n        return true;\n      } catch (e) {\n        if (e instanceof should.AssertionError) {\n          // Caught an AssertionError, return false to the iterator\n          return false;\n        }\n        throw e;\n      }\n    }));\n  });\n\n  Assertion.alias('matchAny', 'matchSome');\n  Assertion.alias('matchEach', 'matchEvery');\n};\n"]}